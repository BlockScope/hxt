
For each of ·length·, ·maxLength· and ·minLength·, the unit of length is measured in number of list items.
The value of ·whiteSpace· is fixed to the value collapse.

<xs:simpleType name='myList'>
	<xs:list itemType='xs:integer'/>
</xs:simpleType>
<xs:simpleType name='myRestrictedList'>
	<xs:restriction base='myList'>
		<xs:pattern value='123 (\d+\s)*456'/>
	</xs:restriction>
</xs:simpleType>

<someElement xsi:type='myRestrictedList'>123 456</someElement>
<someElement xsi:type='myRestrictedList'>123 987 456</someElement>
<someElement xsi:type='myRestrictedList'>123 987 567 456</someElement>

------------------------------------------------------------------------

uppercase / lowercase for attr names elem names ...

attrUse for AttrRef allowed?
pickling: print warning if attributes are used which are not expected: e.g. name + ref together

Validate namespaces:
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" targetNamespace="http://example.org/person">
<tns:family xmlns:tns="http://example.org/person">

prevent infinite recursion on type references

-- let proc = fromMaybe "strict" $ processContents an
-- case proc of
--   "skip"   -> -- no need to validate
--   "lax"    -> -- validate elements against their schemas if loadable, error if invalid
--   "strict" -> -- validate elements against their schemas, error if invalid or schema not loadable

------------------------------------------------------------------------

Do not resolve the same include multiple times (allowed in XML Schema)
Include:
Inclusion of a schema for the same target namespace
(or which has no namespace -> conversion to including document's targetNamespace if it has one)
Import:
Nothing to do: Import of a schema for another target namespace 
(or which has no namespace -> conversion to including document's targetNamespace if it has one)
Redefine:
Same as include but apply redefinitions on referenced schema before merging

------------------------------------------------------------------------

HUnit + Testcases

Haskell 2 LateX Converter: h2l, hs2l
Andres Löh, Ralf Hinze

Experience with standard documents, quality / precision, problems

------------------------------------------------------------------------

TODO: find node for XPath and print it

Text.XML.HXT.XPath.XPathEval
getXPath :: String -> XmlTree -> XmlTrees
Postprocess: take XPath and add error msg as processing instr. in document
<?hxt-validate error="...." ?>

------------------------------------------------------------------------

-- Save schema to given target file

-- fromSchema :: XmlSchema -> XmlSchema'
-- fromSchema s
--   = XmlSchema' (sTargetNS s) $ concat [ins, sts, cts, els, grs, ats, ags]
--     where
--     ins = map In $ sIncludes s
--     sts = map St $ toList $ sSimpleTypes s
--     cts = map Ct $ toList $ sComplexTypes s
--     els = map El $ elems  $ sElements s
--     grs = map Gr $ toList $ sGroups s 
--     ats = map At $ elems  $ sAttributes s
--     ags = map Ag $ toList $ sAttributeGroups s

-- storeXmlSchema :: XmlSchema -> String -> IO ()
-- storeXmlSchema s t
--   = do
--     _ <- runX ( constA (fromSchema s)
--                 >>>
--                 xpickleDocument   xpXmlSchema'
--                                   [ withIndent yes          -- indent generated xml
--                                   ] t
--               )
--     return ()

