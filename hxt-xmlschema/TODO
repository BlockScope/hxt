
For each of ·length·, ·maxLength· and ·minLength·, the unit of length is measured in number of list items.
The value of ·whiteSpace· is fixed to the value collapse.

<xs:simpleType name='myList'>
	<xs:list itemType='xs:integer'/>
</xs:simpleType>
<xs:simpleType name='myRestrictedList'>
	<xs:restriction base='myList'>
		<xs:pattern value='123 (\d+\s)*456'/>
	</xs:restriction>
</xs:simpleType>

<someElement xsi:type='myRestrictedList'>123 456</someElement>
<someElement xsi:type='myRestrictedList'>123 987 456</someElement>
<someElement xsi:type='myRestrictedList'>123 987 567 456</someElement>

------------------------------------------------------------------------

relative paths for import / include / redefine uris, relative to including document

xsi:type
substitutionGroups

uppercase / lowercase for attr names elem names ...

attrUse for AttrRef allowed?
pickling: print warning if attributes are used which are not expected: e.g. name + ref together

Validate namespaces:
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" targetNamespace="http://example.org/person">
<tns:family xmlns:tns="http://example.org/person">

prevent infinite recursion on type references

-- let proc = fromMaybe "strict" $ processContents an
-- case proc of
--   "skip"   -> -- no need to validate
--   "lax"    -> -- validate elements against their schemas if loadable, error if invalid
--   "strict" -> -- validate elements against their schemas, error if invalid or schema not loadable

------------------------------------------------------------------------

Do not resolve the same include multiple times (allowed in XML Schema)
Include:
Inclusion of a schema for the same target namespace
(or which has no namespace -> conversion to including document's targetNamespace if it has one)
Import:
Nothing to do: Import of a schema for another target namespace 
(or which has no namespace -> conversion to including document's targetNamespace if it has one)
Redefine:
Same as include but apply redefinitions on referenced schema before merging

------------------------------------------------------------------------

Haskell 2 LateX Converter: h2l, hs2l
Andres Löh, Ralf Hinze

Experience with standard documents, quality / precision, problems

Code coverage:
add -fhpc in .cabal at section ghc-prof-options
compile and run program
create markup htmls via: cd src && hpc markup Main

------------------------------------------------------------------------

TODO: find node for XPath and print it
Text.XML.HXT.XPath.XPathEval
getXPath :: String -> XmlTree -> XmlTrees
Postprocess: take XPath and add error msg as processing instr. in document
<?hxt-validate error="...." ?>

