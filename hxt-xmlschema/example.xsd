<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" targetNamespace="http://www.example.com/example">

  <!-- simple types (restrictions) -->

  <!--
   TODO:
   <xs:simpleType
           final         = ( "#all" | ( "list" | "union" | "restriction" ) ), nur wenn globale Definition
           name          = xs:NCName, nur wenn globale Definition
           Content: (xs:restriction | xs:list | xs:union)
   </xs:simpleType>
  -->

  <xs:simpleType name="monatInt">
    <xs:restriction base="xs:integer">
      <xs:minInclusive value="1"/>
      <xs:maxInclusive value="12"/>
      <!--
       TODO:

       <xs:minInclusive
           fixed          = xs:boolean : "false"
           value          = anySimpleType
       </xs:minInclusive>

       <xs:minExclusive
           fixed          = xs:boolean : "false"
           value          = anySimpleType
       </xs:minExclusive>

       <xs:maxExclusive
           fixed          = xs:boolean : "false"
           value          = anySimpleType
       </xs:maxExclusive>

       <xs:maxInclusive
           fixed          = xs:boolean : "false"
           value          = anySimpleType
       </xs:maxInclusive>
      -->
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="celsiusKörperTemp">
    <xs:restriction base="xs:decimal">
      <!--
       TODO:
       <xs:totalDigits
           fixed          = xs:boolean : "false"
           value          = xs:positiveInteger
       </xs:totalDigits>
      -->
      <xs:totalDigits value="3"/>
      <!--
       TODO:
       <xs:fractionDigits
           fixed          = xs:boolean : "false"
           value          = xs:nonNegativeInteger
       </xs:fractionDigits>
      -->
      <xs:fractionDigits value="1"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="monatsname">
    <xs:restriction base="xs:string">
      <!--
       TODO:
       <xs:enumeration
           value          = anySimpleType
       </xs:enumeration>
      -->
      <xs:enumeration value="Jan"/>
      <xs:enumeration value="Feb"/>
      <xs:enumeration value="Mär"/>
      <xs:enumeration value="Apr"/>
      <xs:enumeration value="Mai"/>
      <xs:enumeration value="Jun"/>
      <xs:enumeration value="Jul"/>
      <xs:enumeration value="Aug"/>
      <xs:enumeration value="Sep"/>
      <xs:enumeration value="Okt"/>
      <xs:enumeration value="Nov"/>
      <xs:enumeration value="Dez"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="plz">
    <xs:restriction base="xs:string">
      <xs:pattern value="(D )?[0-9]{5}"/>
      <!--
       <xs:pattern
           value          = anySimpleType
       </xs:pattern>
      -->
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="password">
    <!--
     TODO:

     In simpleType (local oder global):
     <xs:restriction
           base          = xs:QName only allowed if no nested simpleType
           Content: xs:simpleType?,
                    ( xs:minExclusive | xs:minInclusive | xs:maxExclusive | xs:maxInclusive
                    | xs:totalDigits | xs:fractionDigits
                    | xs:length | xs:minLength | xs:maxLength
                    | xs:enumeration
                    | xs:pattern
                    | xs:whiteSpace
                    )*
     </xs:restriction>

     In xs:simpleContent (inside ComplexType Def):
     "allows the addition of new constraints to both the attributes and the text node"
     text node: like in simpleType restrictions
     attributes: list of modified attribute definitions or references (must be derivations of original attribute definitions / types)
     <xs:restriction
           base          = xs:QName only allowed if no nested simpleType
           Content: xs:simpleType?,
                    ( xs:minExclusive | xs:minInclusive | xs:maxExclusive | xs:maxInclusive
                    | xs:totalDigits | xs:fractionDigits
                    | xs:length | xs:minLength | xs:maxLength
                    | xs:enumeration
                    | xs:pattern
                    | xs:whiteSpace
                    )*,
                    (xs:attribute | xs:attributeGroup)*, xs:anyAttribute?
     </xs:restriction>

     In xs:complexContent (inside ComplexType Def):
     <xs:restriction
           base          = xs:QName
           Content: (xs:group | xs:all | xs:choice | xs:sequence)?,
                    (xs:attribute | xs:attributeGroup)*, xs:anyAttribute?
     </xs:restriction>

     treatment to perform on whitespace: #x20 (space), #x9 (tab), #xA (linefeed), and #xD (carriage return)
     preserve (whitespace characters are kept unchanged),
     replace (all instances of whitespace are replaced with a space),
     collapse (leading and trailing whitespace is removed, the rest is treated like replace)
     <xs:whiteSpace
           fixed          = xs:boolean : "false"
           value          = ( "preserve" | "replace" | "collapse" )
     </xs:whiteSpace>

    -->
    <xs:restriction base="xs:string">
      <xs:minLength value="5"/>
      <xs:maxLength value="30"/>
      <!--
       TODO:
       <xs:length
           fixed          = xs:boolean : "false"
           value          = xs:nonNegativeInteger
       </xs:length>

       <xs:minLength
           fixed          = xs:boolean : "false"
           value          = xs:nonNegativeInteger
       </xs:minLength>

       <xs:maxLength
           fixed          = xs:boolean : "false"
           value          = xs:nonNegativeInteger
       </xs:maxLength>
      -->
    </xs:restriction>
  </xs:simpleType>

  <!-- simple types (list / union) -->

  <xs:simpleType name="monate">
    <xs:list itemType="monatInt"/>
    <!--
     TODO:
     <xs:list
           itemType         = xs:QName only allowed if no nested simpleType
           Content: xs:simpleType?
     </xs:list> 
    -->
  </xs:simpleType>

  <xs:simpleType name="monat">
    <!--
     TODO:
     <xs:union
           memberTypes = list of xs:QName can be mixed with nested simpleTypes, delimiter: space
           Content: xs:simpleType*
     </xs:union>
    -->
    <xs:union memberTypes="monatsname monatInt"/>
  </xs:simpleType>

  <!-- complex types (sequence, choice, all TODO: group) -->

  <!--
   TODO:
   <xs:complexType
           abstract       = xs:boolean : "false", nur wenn globale Definition
           block          = ( "#all" | list of ( "extension" | "restriction" ) ), nur wenn globale Definition
           final          = ( "#all" | list of ( "extension" | "restriction" ) ), nur wenn globale Definition
           mixed          = xs:boolean : "false"
           name           = xs:NCName, nur wenn globale Definition
           Content: ( xs:simpleContent
                    | xs:complexContent
                    | (xs:group | xs:all | xs:choice | xs:sequence)?, (xs:attribute | xs:attributeGroup)*, xs:anyAttribute?
                    )
   </xs:complexType>
  -->

  <xs:complexType name="pc-Typ">
    <!--
     TODO:
     <xs:sequence
           maxOccurs          = ( xs:nonNegativeInteger | "unbounded" ) : "1", außer wenn Unterelement von xs:group.
           minOccurs          = xs:nonNegativeInteger : "1", außer wenn Unterelement von xs:group.
           Content: (xs:element | xs:group | xs:choice | xs:sequence | xs:any)*
     </xs:sequence>
    -->

    <xs:sequence>
      <xs:element name="name" type="xs:string"/>
      <xs:element name="hersteller" type="xs:string"/>
      <xs:element name="prozessor" type="xs:string"/>
      <xs:element name="mhz" type="xs:integer" minOccurs="0"/>
      <xs:element name="kommentar" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="id" type="xs:integer"/>
  </xs:complexType>

  <xs:complexType name="computer">
    <xs:choice>
      <xs:element name="desktop" type="pc-Typ"/>
      <xs:element name="laptop" type="pc-Typ"/>
    </xs:choice>
    <!--
     TODO:
     <xs:choice
           maxOccurs          = ( xs:nonNegativeInteger | "unbounded" ) : "1", außer wenn Unterelement von xs:group.
           minOccurs          = xs:nonNegativeInteger : "1", außer wenn Unterelement von xs:group.
           Content: (xs:element | xs:group | xs:choice | xs:sequence | xs:any)*
     </xs:choice>
    -->
  </xs:complexType>

  <xs:complexType name="set">
    <xs:all>
      <!--
       "unordered group of elements"
       xs:all: Mittels des xs:all-Tags lässt sich eine Gruppe von Kindelementen definieren,
       von denen jedes maximal einmal auftreten darf (min- und maxOccurs der Kindelemente dürfen nur die Werte 0 oder 1 annehmen).
       Die Reihenfolge der Elemente ist beliebig.
       TODO:
       <xs:all
           maxOccurs          = "1" : "1", außer wenn Unterelement von xs:group.
           minOccurs          = ( "0" | "1" ) : "1", außer wenn Unterelement von xs:group.
           Content: xs:element*
       </xs:all>
      -->
      <xs:element name="first" type="xs:string32" minOccurs="0"/>
      <xs:element name="middle" type="xs:string32" minOccurs="0"/>
      <xs:element name="last" type="xs:string32"/>
    </xs:all>
  </xs:complexType>

  <!-- complex types (extension / restriction) -->

  <xs:complexType name="myPC-Typ">
    <xs:complexContent>
      <!--
       TODO:
       <xs:complexContent
           mixed          = xs:boolean
           Content: (xs:restriction | xs:extension)
       </xs:complexContent>

       Extension:

       Innerhalb von xs:simpleContent: new attributes for the simple base type
       <xs:extension
           base          = xs:QName
           Content: (xs:attribute | xs:attributeGroup)*, xs:anyAttribute?
       </xs:extension>

       Innerhalb von xs:complexContent: new attributes and child elements for the complex base type
       <xs:extension
           base          = xs:QName
           Content: (xs:group | xs:all | xs:choice | xs:sequence)?,
                    (xs:attribute | xs:attributeGroup)*, xs:anyAttribute?
       </xs:extension>

      -->
      <xs:extension base="pc-Typ">
        <xs:sequence>
          <xs:element name="ram" type="xs:integer"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="myPC-Typ2">
    <xs:complexContent>
      <xs:restriction base="pc-Typ">
        <xs:sequence>
          <xs:element name="name" type="xs:string"/>
          <xs:element name="hersteller" type="xs:string"/>
          <xs:element name="prozessor" type="xs:string"/>
          <xs:element name="mhz" type="xs:integer" minOccurs="0"/>
          <xs:element name="kommentar" type="xs:string" minOccurs="0" maxOccurs="1"/>
        </xs:sequence>
      </xs:restriction>
    </xs:complexContent>
  </xs:complexType>

  <!--
   Bei der Definition eines Typs ist es möglich festzulegen, ob und auf welche Art von diesem Typ weitere XML-Elementtypen abgeleitet werden dürfen.
   So kann man zum Beispiel festlegen, dass von einem Typ pc-Typ weitere Typen nur durch das Setzen weiterer Einschränkungen abgeleitet werden dürfen
   und nicht durch das Hinzufügen neuer Kindelemente.
  -->

  <!-- element definitions (with anonymous type declarations) -->

  <!--
   TODO:
   <xs:element
           abstract          = xs:boolean : "false", nur wenn globale definition
           block             = ( "#all" | list of ( "extension" | "restriction" | "substitution" ) )
           default           = xs:string
           final             = ( "#all" | list of ( "extension" | "restriction" ) ), nur wenn globale definition
           fixed             = xs:string
           form              = ( "qualified" | "unqualified" ), nicht wenn globale definition
           maxOccurs         = ( "0" | "1" ) : "1", nicht wenn globale definition
           minOccurs         = ( "0" | "1" ) : "1", nicht wenn globale definition
           name              = xs:NCName
           nillable          = xs:boolean : "false"
           ref               = xs:QName, nicht wenn globale definition
           substitutionGroup = xs:QName, nur wenn globale definition
           type              = xs:QName, nur, wenn keine nested definition
           Content: (xs:simpleType | xs:complexType)?,
                    (xs:unique | xs:key | xs:keyref)*
   </xs:element>
  -->

  <!-- type references -->

  <xs:element name="head">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="title" type="xs:string"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <!-- element references -->

  <xs:element name="html">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="head"/>
        <xs:element name="body" type="xs:string"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <!-- includes / imports / redefines -->

  <xs:include schemaLocation="incl.xsd"/>
  <!--
   targetNamespace des harddisk.xsd muss mit dem des inkludierenden Schemas übereinstimmen.

   TODO:
   <xs:include
           schemaLocation = xs:anyURI
   </xs:include>

   xs:include performs a straight inclusion of a schema within another schema that describes the same target namespace.
   It is possible, though, to include a schema that doesn't specify a target namespace.
   The included schema will be treated as adopting the target namespace of its includer in a schema with a target namespace.

   The effect of a schema inclusion is a merge between the two schemas that are consolidated into a global schema. The schema that is included doesn't need to be a complete schema by itself. 

   It is not possible to use xs:include to include a schema describing another namespace. (xs:import should be used in this case.)
   It is not possible to change the definitions of the included schemas. (xs:redefine should be used in this case.) 

  -->

  <xs:import namespace="http://dyomedea.com/ns/people" schemaLocation="incl.xsd"/>
  <!-- xs:schemaLocation="simple-2-ns-ppl.xsd" -->
  <!--
   TODO:
   <xs:import
           namespace        = xs:anyURI
           schemaLocation   = xs:anyURI
   </xs:import>

   All the global definitions (elements, attributes, element and attribute groups, simple and complex types) and unique and key constraints
   of the imported schemas can be referenced using a namespace prefix defined for the corresponding namespace URI.

   <xs:schema targetNamespace="http://dyomedea.com/ns/library" xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:ppl="http://dyomedea.com/ns/people">
    <xs:import namespace="http://dyomedea.com/ns/people" schemaLocation="simple-2-ns-ppl.xsd"/>
                                 ...
            <xs:element ref="ppl:person" maxOccurs="unbounded"/>
                                 ...
   </xs:schema>

   xs:import must not be used to import component definitions from the target namespace (only xs:include / xs:redefine)

  -->

  <xs:redefine schemaLocation="incl.xsd">
    <xs:complexType name="Hersteller">
      <xs:complexContent>
        <xs:restriction base="pcTeile:Hersteller">
          <xs:sequence>
            <xs:element name="hersteller" type="xs:string" minOccurs="10" maxOccurs="10"/>
          </xs:sequence>
        </xs:restriction>
      </xs:complexContent>
    </xs:complexType>
  </xs:redefine>

  <!--
   TODO:
   <xs:redefine
           schemaLocation = xs:anyURI
           Content: (xs:simpleType | xs:complexType | xs:group | xs:attributeGroup)*
   </xs:redefine>

   xs:redefine is similar to xs:include with one exception:
   the definition of simple and complex types and attribute and element groups can be changed.
   Changes performed on these components must lead to components that are valid restrictions or extensions of the original ones.

   the new types must be defined as derivations by restriction or extension of their previous definition,
   which is considered to be the base type.

   Element and attribute groups are redefined by giving a new definition,
   and may refer to themselves to indicate that the content of their original definition must be included.
   In this case, this self-reference is not considered a recursive definition, but an extension of the original group.

  -->

  <!-- MISSING ELEMENTS:

globale definition (kann über ref-Attribut referenziert werden):
<xs:attribute
           default        = xs:string
           fixed          = xs:string
           name           = xs:NCName
           type           = xs:QName
           Content: xs:simpleType? nur wenn nicht type-Attribut definiert
</xs:attribute>

lokale definition:
<xs:attribute
           default        = xs:string
           fixed          = xs:string
           form           = ( "qualified" | "unqualified" )
           name           = xs:NCName
           ref            = xs:QName 
           type           = xs:QName nur wenn nicht ref-Attribut definiert
           use            = ( "prohibited" | "optional" | "required" ) : "optional"
           Content: xs:simpleType? nur wenn nicht ref-Attribut definiert und nur wenn nicht type-Attribut definiert
</xs:attribute>

globale definition:
<xs:attributeGroup
           name          = xs:NCName
           Content: (xs:attribute | xs:attributeGroup)*, xs:anyAttribute?
</xs:attributeGroup>

referenz (lokal):
<xs:attributeGroup
           ref          = xs:QName
</xs:attributeGroup>

globale Definition:
<xs:group
           name               = xs:NCName
           Content: (xs:all | xs:choice | xs:sequence)
</xs:group>

lokale Definition:
<xs:group
           maxOccurs   = ( xs:nonNegativeInteger | "unbounded" ) : "1"
           minOccurs   = xs:nonNegativeInteger : "1"
           ref         = xs:QName
</xs:group>

<xs:simpleContent
           Content: (xs:restriction | xs:extension)
</xs:simpleContent>

This element allows the definition of a simple content model by derivation of a simple type or of another simple content complex type.
It is not a component by itself (simple contents are not named) but rather declaration of the intention to define a simple content model by derivation. 

<xs:element name="title">
  <xs:complexType>
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute ref="lang"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>
</xs:element>

<xs:any
           maxOccurs          = ( xs:nonNegativeInteger | "unbounded" ) : "1"
           minOccurs          = xs:nonNegativeInteger : "1"
           namespace          = ( ( "##any" | "##other" ) | list of ( xs:anyURI | ( "##targetNamespace" | "##local" ) ) ) : "##any"
           processContents    = ( "skip" | "lax" | "strict" ) : "strict"
</xs:any>

<xs:anyAttribute
           namespace          = ( ( "##any" | "##other" ) | list of ( xs:anyURI | ( "##targetNamespace" | "##local" ) ) ) : "##any"
           processContents    = ( "skip" | "lax" | "strict" ) : "strict"
</xs:anyAttribute>

<xs:notation
           name          = xs:NCName
           public        = xs:token
           system        = xs:anyURI
</xs:notation>

<xs:notation name="pdf" public="application/pdf"
  system="file:///usr/bin/acroread"/>

<xs:simpleType name="graphicalFormat">
  <xs:restriction base="xs:NOTATION">
    <xs:enumeration value="jpeg"/>
    <xs:enumeration value="gif"/>
    <xs:enumeration value="png"/>
    <xs:enumeration value="svg"/>
    <xs:enumeration value="pdf"/>
  </xs:restriction>
</xs:simpleType>

  -->

  <!-- cabinet of curiosities -->

  <xs:element name="kommentar" type="xs:anyType"/>

  <xs:element name="tagname">
    <xs:complexType mixed="true">  <!-- text and tags can occur in mixed order -->
      <xs:sequence>
        <xs:element name="child" type="xs:integer" minOccurs="0" maxOccurs="unbounded"/>
        <!-- Weitere Elemente … -->
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <!--
   Von leeren XML-Elementen spricht man, wenn das jeweilige Element aus nur einem einzelnen XML-Tag besteht und keine weiteren XML-Elemente oder Text umschließt
   (z. B. der XHTML-Zeilenumbruch: <br />). XML Schema bedient sich an dieser   Stelle eines kleinen Tricks: Es wird mittels xs:complexType ein neuer Typ definiert,
   ohne ein Kindelement anzugeben. Da xs:complexType nach Vorgabe nur komplexe XML-Kindelemente als Inhalt zulässt, bleibt das jeweilige Element in diesem Fall leer.
  -->

  <!--
   Schlüssel: xs:key, xs:unique, xs:keyref ...

   <xs:unique
           name          = xs:NCName
           Content: xs:selector, xs:field+
   </xs:unique>

   <xs:field
           xpath          = xs:token
   </xs:field>

   <xs:key
           name          = xs:NCName
           Content: xs:selector, xs:field+
   </xs:key>

   <xs:keyref
           name          = xs:NCName
           refer         = xs:QName
           Content: xs:selector, xs:field+
   </xs:keyref>

   <xs:selector
           xpath          = xs:token
   </xs:selector>
  -->

</xs:schema>
