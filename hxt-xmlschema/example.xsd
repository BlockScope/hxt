<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" targetNamespace="http://www.example.com/example">

  <!--
   TODO:
   <xs:schema
           attributeFormDefault = ( "qualified" | "unqualified" ) : "unqualified"
           blockDefault         = ( "#all" | list of ( "extension" | "restriction" | "substitution" ) ) : ""
           elementFormDefault   = ( "qualified" | "unqualified" ) : "unqualified"
           finalDefault         = ( "#all" | list of ( "extension" | "restriction" ) ) : ""
           id                   = xs:ID
           targetNamespace      = xs:anyURI
           version              = xs:token
           xml:lang             = xml:lang
           Content: ((xs:include | xs:import | xs:redefine | xs:annotation)*, (,
                      ( | (xs:simpleType | xs:complexType | xs:group |
                      xs:attributeGroup) | xs:element | xs:attribute |
                      xs:notation), xs:annotation*)*)
   </xs:schema>
  -->

  <!-- base types -->

  <!--
   Vordefinierte Typen (unvollständig):

   xs:string
   xs:decimal
   xs:integer
   xs:float
   xs:boolean
   xs:date
   xs:time

   QName: Qualified Name, global eindeutiger Bezeichner, einzelne NCNames werden mittels Punkt (.) zu einem QName zusammengesetzt.
   anyURI: Uniform Resource Identifier (URI)
   language: Sprachbezeichnung, z. B. de-DE, en-US, fr
   ID: Identifikationsattribut innerhalb von XML-Elementen
   IDREF: Referenz auf einen ID-Wert
  -->

  <!-- simple types (restrictions) -->

  <!--
   TODO:
   <xs:simpleType
           final         = ( "#all" | ( "list" | "union" | "restriction" ) ), nur wenn globale Definition
           id            = xs:ID
           name          = xs:NCName, nur wenn globale Definition
           Content: (xs:annotation?, (xs:restriction | xs:list | xs:union))
   </xs:simpleType>
  -->


  <xs:simpleType name="monatInt">
    <xs:restriction base="xs:integer">
      <xs:minInclusive value="1"/>
      <xs:maxInclusive value="12"/>
      <!--
       TODO:

       <xs:minInclusive
           fixed          = xs:boolean : "false"
           id             = xs:ID
           value          = anySimpleType
           Content: (xs:annotation?)
       </xs:minInclusive>

       <xs:minExclusive
           fixed          = xs:boolean : "false"
           id             = xs:ID
           value          = anySimpleType
           Content: (xs:annotation?)
       </xs:minExclusive>

       <xs:maxExclusive
           fixed          = xs:boolean : "false"
           id             = xs:ID
           value          = anySimpleType
           Content: (xs:annotation?)
       </xs:maxExclusive>

       <xs:maxInclusive
           fixed          = xs:boolean : "false"
           id             = xs:ID
           value          = anySimpleType
           Content: (xs:annotation?)
       </xs:maxInclusive>
      -->
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="celsiusKörperTemp">
    <xs:restriction base="xs:decimal">
      <!--
       TODO:
       <xs:totalDigits
           fixed          = xs:boolean : "false"
           id             = xs:ID
           value          = xs:positiveInteger
           Content: (xs:annotation?)
       </xs:totalDigits>
      -->
      <xs:totalDigits value="3"/>
      <!--
       TODO:
       <xs:fractionDigits
           fixed          = xs:boolean : "false"
           id             = xs:ID
           value          = xs:nonNegativeInteger
           Content: (xs:annotation?)
       </xs:fractionDigits>
      -->
      <xs:fractionDigits value="1"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="monatsname">
    <xs:restriction base="xs:string">
      <!--
       TODO:
       <xs:enumeration
           id             = xs:ID
           value          = anySimpleType
           Content: (xs:annotation?)
       </xs:enumeration>
      -->
      <xs:enumeration value="Jan"/>
      <xs:enumeration value="Feb"/>
      <xs:enumeration value="Mär"/>
      <xs:enumeration value="Apr"/>
      <xs:enumeration value="Mai"/>
      <xs:enumeration value="Jun"/>
      <xs:enumeration value="Jul"/>
      <xs:enumeration value="Aug"/>
      <xs:enumeration value="Sep"/>
      <xs:enumeration value="Okt"/>
      <xs:enumeration value="Nov"/>
      <xs:enumeration value="Dez"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="plz">
    <xs:restriction base="xs:string">
      <xs:pattern value="(D )?[0-9]{5}"/>
      <!--
       <xs:pattern
           id             = xs:ID
           value          = anySimpleType
           Content: (xs:annotation?)
       </xs:pattern>
      -->
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="password">
    <!--
     TODO:
     <xs:restriction
           base          = xs:QName
           id            = xs:ID
           Content: ((xs:annotation?), (xs:simpleType?, (xs:minExclusive |
                      xs:minInclusive | xs:maxExclusive | xs:maxInclusive |
                      xs:totalDigits | xs:fractionDigits | xs:length |
                      xs:minLength | xs:maxLength | xs:enumeration |
                      xs:whiteSpace | xs:pattern)*))
     </xs:restriction>

     In xs:simpleContent:
     <xs:restriction
           base          = xs:QName
           id            = xs:ID
           Content: (xs:annotation?, (xs:simpleType?, (xs:minExclusive |
                      xs:minInclusive | xs:maxExclusive | xs:maxInclusive |
                      xs:totalDigits | xs:fractionDigits | xs:length |
                      xs:minLength | xs:maxLength | xs:enumeration | xs:whiteSpace |
                      xs:pattern)*)?, ((xs:attribute | xs:attributeGroup)*,
                      xs:anyAttribute?))
     </xs:restriction>

     In xs:complexContent:
     <xs:restriction
           base          = xs:QName
           id            = xs:ID
           Content: (xs:annotation?, (xs:group | xs:all | xs:choice | xs:sequence)?,
                      ((xs:attribute | xs:attributeGroup)*, xs:anyAttribute?))
     </xs:restriction>

     <xs:whiteSpace
           fixed          = xs:boolean : "false"
           id             = xs:ID
           value          = ( "preserve" | "replace" | "collapse" )
           Content: (xs:annotation?)
     </xs:whiteSpace>

    -->
    <xs:restriction base="xs:string">
      <xs:minLength value="5"/>
      <xs:maxLength value="30"/>
      <!--
       TODO:
       <xs:length
           fixed          = xs:boolean : "false"
           id             = xs:ID
           value          = xs:nonNegativeInteger
           Content: (xs:annotation?)
       </xs:length>

       <xs:minLength
           fixed          = xs:boolean : "false"
           id             = xs:ID
           value          = xs:nonNegativeInteger
           Content: (xs:annotation?)
       </xs:minLength>

       <xs:maxLength
           fixed          = xs:boolean : "false"
           id             = xs:ID
           value          = xs:nonNegativeInteger
           Content: (xs:annotation?)
       </xs:maxLength>
      -->
    </xs:restriction>
  </xs:simpleType>

  <!-- simple types (list / union) -->

  <xs:simpleType name="monate">
    <xs:list itemType="monatInt"/>
    <!--
     TODO:
     <xs:list
           id               = xs:ID
           itemType         = xs:QName
           Content: ((xs:annotation?), (xs:simpleType?))
     </xs:list> 
    -->
  </xs:simpleType>

  <xs:simpleType name="monat">
    <!--
     TODO:
     <xs:union
           id          = xs:ID
           memberTypes = list of xs:QName
           Content: ((xs:annotation?), (xs:simpleType*))
     </xs:union>
    -->
    <xs:union memberTypes="monatsname monatInt"/>
  </xs:simpleType>

  <!-- complex types (sequence, choice, all) -->

  <!--
   TODO:
   <xs:complexType
           abstract       = xs:boolean : "false", nur wenn globale Definition
           block          = ( "#all" | list of ( "extension" | "restriction" ) ), nur wenn globale Definition
           final          = ( "#all" | list of ( "extension" | "restriction" ) ), nur wenn globale Definition
           id             = xs:ID
           mixed          = xs:boolean : "false"
           name           = xs:NCName, nur wenn globale Definition
           Content: (xs:annotation?, (xs:simpleContent | xs:complexContent | (, (xs:group | xs:all | xs:choice | xs:sequence)?, ((xs:attribute | xs:attributeGroup)*, xs:anyAttribute? ?))))
   </xs:complexType>
  -->

  <xs:complexType name="pc-Typ">
    <!--
     TODO:
      <xs:sequence
           id                 = xs:ID
           maxOccurs          = ( xs:nonNegativeInteger | "unbounded" ) : "1", außer wenn Unterelement von xs:group.
           minOccurs          = xs:nonNegativeInteger : "1", außer wenn Unterelement von xs:group.
           Content: (xs:annotation?, (xs:element | xs:group | xs:choice | xs:sequence | xs:any) )*)
     </xs:sequence>
    -->

    <xs:sequence>
      <xs:element name="name" type="xs:string"/>
      <xs:element name="hersteller" type="xs:string"/>
      <xs:element name="prozessor" type="xs:string"/>
      <xs:element name="mhz" type="xs:integer" minOccurs="0"/>
      <xs:element name="kommentar" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="id" type="xs:integer"/>
  </xs:complexType>

  <xs:complexType name="computer">
    <xs:choice>
      <xs:element name="desktop" type="pc-Typ"/>
      <xs:element name="laptop" type="pc-Typ"/>
    </xs:choice>
    <!--
     TODO:
     <xs:choice
           id                 = xs:ID
           maxOccurs          = ( xs:nonNegativeInteger | "unbounded" ) : "1", außer wenn Unterelement von xs:group.
           minOccurs          = xs:nonNegativeInteger : "1", außer wenn Unterelement von xs:group.
           Content: (xs:annotation?, (xs:element | xs:group | xs:choice | xs:sequence | xs:any) )*)
     </xs:choice>
    -->
  </xs:complexType>

  <xs:complexType name="set">
    <xs:all>
      <!--
       xs:all: Mittels des xs:all-Tags lässt sich eine Gruppe von Kindelementen definieren,
       von denen jedes maximal einmal auftreten darf (min- und maxOccurs der Kindelemente dürfen nur die Werte 0 oder 1 annehmen).
       Die Reihenfolge der Elemente ist beliebig.
       TODO:
       <xs:all
           id                 = xs:ID
           maxOccurs          = "1" : "1", außer wenn Unterelement von xs:group.
           minOccurs          = ( "0" | "1" ) : "1", außer wenn Unterelement von xs:group.
           Content: (xs:annotation?, xs:element*)
       </xs:all>
      -->
      <xs:element name="first" type="string32" minOccurs="0"/>
      <xs:element name="middle" type="string32" minOccurs="0"/>
      <xs:element name="last" type="string32"/>
    </xs:all>
  </xs:complexType>

  <!-- complex types (extension / restriction) -->

  <xs:complexType name="myPC-Typ">
    <xs:complexContent>
      <!--
       TODO:
       <xs:complexContent
           id             = xs:ID
           mixed          = xs:boolean
           Content: ((xs:annotation?), (xs:restriction | xs:extension))
       </xs:complexContent>

       Innerhalb von xs:simpleContent
       <xs:extension
           base          = xs:QName
           id            = xs:ID
           Content: (xs:annotation?, ((xs:attribute | xs:attributeGroup)*, xs:anyAttribute?))
       </xs:extension>

       Innerhalb von xs:complexContent
       <xs:extension
           base          = xs:QName
           id            = xs:ID
           Content: ((xs:annotation?), (, (xs:group | xs:all | xs:choice | xs:sequence)?, ((xs:attribute | xs:attributeGroup)*, xs:anyAttribute?)))
       </xs:extension>

      -->
      <xs:extension base="pc-Typ">
        <xs:sequence>
          <xs:element name="ram" type="xs:integer"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="myPC-Typ2">
    <xs:complexContent>
      <xs:restriction base="pc-Typ">
        <xs:sequence>
          <xs:element name="name" type="xs:string"/>
          <xs:element name="hersteller" type="xs:string"/>
          <xs:element name="prozessor" type="xs:string"/>
          <xs:element name="mhz" type="xs:integer" minOccurs="0"/>
          <xs:element name="kommentar" type="xs:string" minOccurs="0" maxOccurs="1"/>
        </xs:sequence>
      </xs:restriction>
    </xs:complexContent>
  </xs:complexType>

  <!--
   Bei der Definition eines Typs ist es möglich festzulegen, ob und auf welche Art von diesem Typ weitere XML-Elementtypen abgeleitet werden dürfen.
   So kann man zum Beispiel festlegen, dass von einem Typ pc-Typ weitere Typen nur durch das Setzen weiterer Einschränkungen abgeleitet werden dürfen
   und nicht durch das Hinzufügen neuer Kindelemente.
  -->

  <!-- element definitions (with anonymous type declarations) -->

  <!--
   TODO:
   <xs:element
           abstract          = xs:boolean : "false", nur wenn globale definition
           block             = ( "#all" | list of ( "extension" | "restriction" | "substitution" ) )
           default           = xs:string
           final             = ( "#all" | list of ( "extension" | "restriction" ) ), nur wenn globale definition
           fixed             = xs:string
           form          = ( "qualified" | "unqualified" ), nicht wenn globale definition
           id                = xs:ID
           maxOccurs     = ( "0" | "1" ) : "1", nicht wenn globale definition
           minOccurs     = ( "0" | "1" ) : "1", nicht wenn globale definition
           name              = xs:NCName
           nillable          = xs:boolean : "false"
           ref           = xs:QName, nicht wenn globale definition
           substitutionGroup = xs:QName, nur wenn globale definition
           type              = xs:QName
           Content: (xs:annotation?, (xs:simpleType | xs:complexType)?, (xs:unique | xs:key | xs:keyref)*)
   </xs:element>
  -->

  <!-- type references -->

  <xs:element name="head">
    <xs:complexType>
      <xs:sequence>
        <xs:element name="title" type="xs:string"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <!-- element references -->

  <xs:element name="html">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="head"/>
        <xs:element name="body" type="xs:string"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <!-- includes / imports / redefines -->

  <xs:include schemaLocation="http://www.example.com/schemata/harddisk.xsd"/>
  <!--
   targetNamespace des harddisk.xsd muss mit dem des inkludierenden Schemas übereinstimmen.

   TODO:
   <xs:include
           id             = xs:ID
           schemaLocation = xs:anyURI
           Content: (xs:annotation?)
   </xs:include>

   xs:include performs a straight inclusion of a schema within another schema that describes the same target namespace.
   It is possible, though, to include a schema that doesn't specify a target namespace.
   The included schema will be treated as adopting the target namespace of its includer in a schema with a target namespace.

   The effect of a schema inclusion is a merge between the two schemas that are consolidated into a global schema. The schema that is included doesn't need to be a complete schema by itself. 

   It is not possible to use xs:include to include a schema describing another namespace. (xs:import should be used in this case.)
   It is not possible to change the definitions of the included schemas. (xs:redefine should be used in this case.) 

  -->

  <xs:import namespace="http://dyomedea.com/ns/people" schemaLocation="simple-2-ns-ppl.xsd"/>
  <!--
   TODO:
   <xs:import
           id               = xs:ID
           namespace        = xs:anyURI
           schemaLocation   = xs:anyURI
           Content: (xs:annotation?)
   </xs:import>

   All the global definitions (elements, attributes, element and attribute groups, simple and complex types) and unique and key constraints
   of the imported schemas can be referenced using a namespace prefix defined for the corresponding namespace URI.

   <xs:schema targetNamespace="http://dyomedea.com/ns/library" xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:ppl="http://dyomedea.com/ns/people">
    <xs:import namespace="http://dyomedea.com/ns/people" schemaLocation="simple-2-ns-ppl.xsd"/>
                                 ...
            <xs:element ref="ppl:person" maxOccurs="unbounded"/>
                                 ...
   </xs:schema>

   xs:import must not be used to import component definitions from the target namespace (only xs:include / xs:redefine)

  -->

  <xs:redefine schemaLocation="http://www.example.com/schemata/harddisk.xsd">
    <xs:complexType name="Hersteller">
      <xs:complexContent>
        <xs:restriction base="pcTeile:Hersteller">
          <xs:sequence>
            <xs:element name="hersteller" type="string" minOccurs="10" maxOccurs="10"/>
          </xs:sequence>
        </xs:restriction>
      </xs:complexContent>
    </xs:complexType>
  </xs:redefine>

  <!--
   TODO:
   <xs:redefine
           id             = xs:ID
           schemaLocation = xs:anyURI
           Content: (xs:annotation | (xs:simpleType | xs:complexType | xs:group | xs:attributeGroup))*
   </xs:redefine>

   xs:redefine is similar to xs:include with one exception: the definition of simple and complex types and attribute and element groups can be changed.
   Changes performed on these components must lead to     components that are valid restrictions or extensions of the original ones.
  -->

  <!-- MISSING ELEMENTS:

<xs:annotation
           id          = xs:ID
           Content: (xs:appinfo | xs:documentation)*
</xs:annotation>

<xs:appinfo
           source          = xs:anyURI
           Content: ({any})*
</xs:appinfo>

<xs:documentation
           source            = xs:anyURI
           xml:lang          = xml:lang
           Content: ({any})*
</xs:documentation>

globale definition (kann über ref-Attribut referenziert werden):
<xs:attribute
           default        = xs:string
           fixed          = xs:string
           id             = xs:ID
           name           = xs:NCName
           type           = xs:QName
           Content: (xs:annotation?, xs:simpleType?)
</xs:attribute>

lokale definition:
<xs:attribute
           default        = xs:string
           fixed          = xs:string
           form           = ( "qualified" | "unqualified" )
           id             = xs:ID
           name           = xs:NCName
           ref            = xs:QName
           type           = xs:QName
           use            = ( "prohibited" | "optional" | "required" ) : "optional"
           Content: ((xs:annotation?), (xs:simpleType?))
</xs:attribute>

globale definition:
<xs:attributeGroup
           id            = xs:ID
           name          = xs:NCName
           Content: (xs:annotation?, ((xs:attribute | xs:attributeGroup)*, xs:anyAttribute?))
</xs:attributeGroup>

lokale definition:
<xs:attributeGroup
           id           = xs:ID
           ref          = xs:QName
           Content: (xs:annotation?)
</xs:attributeGroup>

globale Definition:
<xs:group
           name               = xs:NCName
           Content: (xs:annotation?, (xs:all | xs:choice | xs:sequence))
</xs:group>

lokale Definition:
<xs:group
           id          = xs:ID
           maxOccurs   = ( xs:nonNegativeInteger | "unbounded" ) : "1"
           minOccurs   = xs:nonNegativeInteger : "1"
           ref         = xs:QName
           Content: (xs:annotation?)
</xs:group>

<xs:simpleContent
           id          = xs:ID
           Content: ((xs:annotation?), (xs:restriction | xs:extension))
</xs:simpleContent>

This element allows the definition of a simple content model by derivation of a simple type or of another simple content complex type.
It is not a component by itself (simple contents are not named) but rather declaration of the intention to define a simple content model by derivation. 

<xs:element name="title">
  <xs:complexType>
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute ref="lang"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>
</xs:element>

<xs:any
           id                 = xs:ID
           maxOccurs          = ( xs:nonNegativeInteger | "unbounded" ) : "1"
           minOccurs          = xs:nonNegativeInteger : "1"
           namespace          = ( ( "##any" | "##other" ) | list of ( xs:anyURI | ( "##targetNamespace" | "##local" ) ) ) : "##any"
           processContents    = ( "skip" | "lax" | "strict" ) : "strict"
           Content: (xs:annotation?)
</xs:any>

<xs:anyAttribute
           id                 = xs:ID
           namespace          = ( ( "##any" | "##other" ) | list of ( xs:anyURI | ( "##targetNamespace" | "##local" ) ) ) : "##any"
           processContents    = ( "skip" | "lax" | "strict" ) : "strict"
           Content: (xs:annotation?)
</xs:anyAttribute>

<xs:notation
           id            = xs:ID
           name          = xs:NCName
           public        = xs:token
           system        = xs:anyURI
           Content: (xs:annotation?)
</xs:notation>

<xs:notation name="pdf" public="application/pdf"
  system="file:///usr/bin/acroread"/>

<xs:simpleType name="graphicalFormat">
  <xs:restriction base="xs:NOTATION">
    <xs:enumeration value="jpeg"/>
    <xs:enumeration value="gif"/>
    <xs:enumeration value="png"/>
    <xs:enumeration value="svg"/>
    <xs:enumeration value="pdf"/>
  </xs:restriction>
</xs:simpleType>

  -->

  <!-- cabinet of curiosities -->

  <xs:element name="kommentar" type="xs:anyType"/>

  <xs:element name="tagname">
    <xs:complexType mixed="true">  <!-- text and tags can occur in mixed order -->
      <xs:sequence>
        <xs:element name="child" type="xs:integer" minOccurs="0" maxOccurs="unbounded"/>
        <!-- Weitere Elemente … -->
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <!--
   Von leeren XML-Elementen spricht man, wenn das jeweilige Element aus nur einem einzelnen XML-Tag besteht und keine weiteren XML-Elemente oder Text umschließt
   (z. B. der XHTML-Zeilenumbruch: <br />). XML Schema bedient sich an dieser   Stelle eines kleinen Tricks: Es wird mittels xs:complexType ein neuer Typ definiert,
   ohne ein Kindelement anzugeben. Da xs:complexType nach Vorgabe nur komplexe XML-Kindelemente als Inhalt zulässt, bleibt das jeweilige Element in diesem Fall leer.
  -->

  <!--
   Schlüssel: xs:key, xs:unique, xs:keyref ...

   <xs:unique
           id            = xs:ID
           name          = xs:NCName
           Content: ((xs:annotation?), (xs:selector, xs:field+))
   </xs:unique>

   <xs:field
           id             = xs:ID
           xpath          = xs:token
           Content: (xs:annotation?)
   </xs:field>

   <xs:key
           id            = xs:ID
           name          = xs:NCName
           Content: ((xs:annotation?), (xs:selector, xs:field+))
   </xs:key>

   <xs:keyref
           id            = xs:ID
           name          = xs:NCName
           refer         = xs:QName
           Content: ((xs:annotation?), (xs:selector, xs:field+))
   </xs:keyref>

   <xs:selector
           id             = xs:ID
           xpath          = xs:token
           Content: (xs:annotation?)
   </xs:selector>
  -->

</xs:schema>
