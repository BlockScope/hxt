<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xs:targetNamespace="http://www.example.com/example">
  <!-- xmlns="...." default ns wirkt nur auf Elemente -->
  <!--
   TODO:
   <xs:schema
           attributeFormDefault = ( "qualified" | "unqualified" ) : "unqualified"
           blockDefault         = ( "#all" | list of ( "extension" | "restriction" | "substitution" ) ) : ""
           elementFormDefault   = ( "qualified" | "unqualified" ) : "unqualified"
           finalDefault         = ( "#all" | list of ( "extension" | "restriction" ) ) : ""
           id                   = xs:ID
           targetNamespace      = xs:anyURI
           version              = xs:token
           xml:lang             = xml:lang
           Content: ((xs:include | xs:import | xs:redefine | xs:annotation)*, (,
                      ( | (xs:simpleType | xs:complexType | xs:group |
                      xs:attributeGroup) | xs:element | xs:attribute |
                      xs:notation), xs:annotation*)*)
   </xs:schema>
  -->

  <!-- simple types (restrictions) -->

  <!--
   TODO:
   <xs:simpleType
           final         = ( "#all" | ( "list" | "union" | "restriction" ) ), nur wenn globale Definition
           id            = xs:ID
           name          = xs:NCName, nur wenn globale Definition
           Content: (xs:annotation?, (xs:restriction | xs:list | xs:union))
   </xs:simpleType>
  -->


  <xs:simpleType xs:name="monatInt">
    <xs:restriction xs:base="xs:integer">
      <xs:minInclusive xs:value="1"/>
      <xs:maxInclusive xs:value="12"/>
      <!--
       TODO:

       <xs:minInclusive
           fixed          = xs:boolean : "false"
           id             = xs:ID
           value          = anySimpleType
           Content: (xs:annotation?)
       </xs:minInclusive>

       <xs:minExclusive
           fixed          = xs:boolean : "false"
           id             = xs:ID
           value          = anySimpleType
           Content: (xs:annotation?)
       </xs:minExclusive>

       <xs:maxExclusive
           fixed          = xs:boolean : "false"
           id             = xs:ID
           value          = anySimpleType
           Content: (xs:annotation?)
       </xs:maxExclusive>

       <xs:maxInclusive
           fixed          = xs:boolean : "false"
           id             = xs:ID
           value          = anySimpleType
           Content: (xs:annotation?)
       </xs:maxInclusive>
      -->
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType xs:name="celsiusKörperTemp">
    <xs:restriction xs:base="xs:decimal">
      <!--
       TODO:
       <xs:totalDigits
           fixed          = xs:boolean : "false"
           id             = xs:ID
           value          = xs:positiveInteger
           Content: (xs:annotation?)
       </xs:totalDigits>
      -->
      <xs:totalDigits xs:value="3"/>
      <!--
       TODO:
       <xs:fractionDigits
           fixed          = xs:boolean : "false"
           id             = xs:ID
           value          = xs:nonNegativeInteger
           Content: (xs:annotation?)
       </xs:fractionDigits>
      -->
      <xs:fractionDigits xs:value="1"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType xs:name="monatsname">
    <xs:restriction xs:base="xs:string">
      <!--
       TODO:
       <xs:enumeration
           id             = xs:ID
           value          = anySimpleType
           Content: (xs:annotation?)
       </xs:enumeration>
      -->
      <xs:enumeration xs:value="Jan"/>
      <xs:enumeration xs:value="Feb"/>
      <xs:enumeration xs:value="Mär"/>
      <xs:enumeration xs:value="Apr"/>
      <xs:enumeration xs:value="Mai"/>
      <xs:enumeration xs:value="Jun"/>
      <xs:enumeration xs:value="Jul"/>
      <xs:enumeration xs:value="Aug"/>
      <xs:enumeration xs:value="Sep"/>
      <xs:enumeration xs:value="Okt"/>
      <xs:enumeration xs:value="Nov"/>
      <xs:enumeration xs:value="Dez"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType xs:name="plz">
    <xs:restriction xs:base="xs:string">
      <xs:pattern xs:value="(D )?[0-9]{5}"/>
      <!--
       <xs:pattern
           id             = xs:ID
           value          = anySimpleType
           Content: (xs:annotation?)
       </xs:pattern>
      -->
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType xs:name="password">
    <!--
     TODO:
     <xs:restriction
           base          = xs:QName
           id            = xs:ID
           Content: ((xs:annotation?), (xs:simpleType?, (xs:minExclusive |
                      xs:minInclusive | xs:maxExclusive | xs:maxInclusive |
                      xs:totalDigits | xs:fractionDigits | xs:length |
                      xs:minLength | xs:maxLength | xs:enumeration |
                      xs:whiteSpace | xs:pattern)*))
     </xs:restriction>

     In xs:simpleContent:
     <xs:restriction
           base          = xs:QName
           id            = xs:ID
           Content: (xs:annotation?, (xs:simpleType?, (xs:minExclusive |
                      xs:minInclusive | xs:maxExclusive | xs:maxInclusive |
                      xs:totalDigits | xs:fractionDigits | xs:length |
                      xs:minLength | xs:maxLength | xs:enumeration | xs:whiteSpace |
                      xs:pattern)*)?, ((xs:attribute | xs:attributeGroup)*,
                      xs:anyAttribute?))
     </xs:restriction>

     In xs:complexContent:
     <xs:restriction
           base          = xs:QName
           id            = xs:ID
           Content: (xs:annotation?, (xs:group | xs:all | xs:choice | xs:sequence)?,
                      ((xs:attribute | xs:attributeGroup)*, xs:anyAttribute?))
     </xs:restriction>

     <xs:whiteSpace
           fixed          = xs:boolean : "false"
           id             = xs:ID
           value          = ( "preserve" | "replace" | "collapse" )
           Content: (xs:annotation?)
     </xs:whiteSpace>

    -->
    <xs:restriction xs:base="xs:string">
      <xs:minLength xs:value="5"/>
      <xs:maxLength xs:value="30"/>
      <!--
       TODO:
       <xs:length
           fixed          = xs:boolean : "false"
           id             = xs:ID
           value          = xs:nonNegativeInteger
           Content: (xs:annotation?)
       </xs:length>

       <xs:minLength
           fixed          = xs:boolean : "false"
           id             = xs:ID
           value          = xs:nonNegativeInteger
           Content: (xs:annotation?)
       </xs:minLength>

       <xs:maxLength
           fixed          = xs:boolean : "false"
           id             = xs:ID
           value          = xs:nonNegativeInteger
           Content: (xs:annotation?)
       </xs:maxLength>
      -->
    </xs:restriction>
  </xs:simpleType>

  <!-- simple types (list / union) -->

  <xs:simpleType xs:name="monate">
    <xs:list xs:itemType="monatInt"/>
    <!--
     TODO:
     <xs:list
           id               = xs:ID
           itemType         = xs:QName
           Content: ((xs:annotation?), (xs:simpleType?))
     </xs:list> 
    -->
  </xs:simpleType>

  <xs:simpleType xs:name="monat">
    <!--
     TODO:
     <xs:union
           id          = xs:ID
           memberTypes = list of xs:QName
           Content: ((xs:annotation?), (xs:simpleType*))
     </xs:union>
    -->
    <xs:union xs:memberTypes="monatsname monatInt"/>
  </xs:simpleType>

  <!-- complex types (sequence, choice, all) -->

  <!--
   TODO:
   <xs:complexType
           abstract       = xs:boolean : "false", nur wenn globale Definition
           block          = ( "#all" | list of ( "extension" | "restriction" ) ), nur wenn globale Definition
           final          = ( "#all" | list of ( "extension" | "restriction" ) ), nur wenn globale Definition
           id             = xs:ID
           mixed          = xs:boolean : "false"
           name           = xs:NCName, nur wenn globale Definition
           Content: (xs:annotation?, (xs:simpleContent | xs:complexContent | (, (xs:group | xs:all | xs:choice | xs:sequence)?, ((xs:attribute | xs:attributeGroup)*, xs:anyAttribute? ?))))
   </xs:complexType>
  -->

  <xs:complexType xs:name="pc-Typ">
    <!--
     TODO:
      <xs:sequence
           id                 = xs:ID
           maxOccurs          = ( xs:nonNegativeInteger | "unbounded" ) : "1", außer wenn Unterelement von xs:group.
           minOccurs          = xs:nonNegativeInteger : "1", außer wenn Unterelement von xs:group.
           Content: (xs:annotation?, (xs:element | xs:group | xs:choice | xs:sequence | xs:any) )*)
     </xs:sequence>
    -->

    <xs:sequence>
      <xs:element xs:name="name" xs:type="xs:string"/>
      <xs:element xs:name="hersteller" xs:type="xs:string"/>
      <xs:element xs:name="prozessor" xs:type="xs:string"/>
      <xs:element xs:name="mhz" xs:type="xs:integer" xs:minOccurs="0"/>
      <xs:element xs:name="kommentar" xs:type="xs:string" xs:minOccurs="0" xs:maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute xs:name="id" xs:type="xs:integer"/>
  </xs:complexType>

  <xs:complexType xs:name="computer">
    <xs:choice>
      <xs:element xs:name="desktop" xs:type="pc-Typ"/>
      <xs:element xs:name="laptop" xs:type="pc-Typ"/>
    </xs:choice>
    <!--
     TODO:
     <xs:choice
           id                 = xs:ID
           maxOccurs          = ( xs:nonNegativeInteger | "unbounded" ) : "1", außer wenn Unterelement von xs:group.
           minOccurs          = xs:nonNegativeInteger : "1", außer wenn Unterelement von xs:group.
           Content: (xs:annotation?, (xs:element | xs:group | xs:choice | xs:sequence | xs:any) )*)
     </xs:choice>
    -->
  </xs:complexType>

  <xs:complexType xs:name="set">
    <xs:all>
      <!--
       xs:all: Mittels des xs:all-Tags lässt sich eine Gruppe von Kindelementen definieren,
       von denen jedes maximal einmal auftreten darf (min- und maxOccurs der Kindelemente dürfen nur die Werte 0 oder 1 annehmen).
       Die Reihenfolge der Elemente ist beliebig.
       TODO:
       <xs:all
           id                 = xs:ID
           maxOccurs          = "1" : "1", außer wenn Unterelement von xs:group.
           minOccurs          = ( "0" | "1" ) : "1", außer wenn Unterelement von xs:group.
           Content: (xs:annotation?, xs:element*)
       </xs:all>
      -->
      <xs:element xs:name="first" xs:type="string32" xs:minOccurs="0"/>
      <xs:element xs:name="middle" xs:type="string32" xs:minOccurs="0"/>
      <xs:element xs:name="last" xs:type="string32"/>
    </xs:all>
  </xs:complexType>

  <!-- complex types (extension / restriction) -->

  <xs:complexType xs:name="myPC-Typ">
    <xs:complexContent>
      <!--
       TODO:
       <xs:complexContent
           id             = xs:ID
           mixed          = xs:boolean
           Content: ((xs:annotation?), (xs:restriction | xs:extension))
       </xs:complexContent>

       Innerhalb von xs:simpleContent
       <xs:extension
           base          = xs:QName
           id            = xs:ID
           Content: (xs:annotation?, ((xs:attribute | xs:attributeGroup)*, xs:anyAttribute?))
       </xs:extension>

       Innerhalb von xs:complexContent
       <xs:extension
           base          = xs:QName
           id            = xs:ID
           Content: ((xs:annotation?), (, (xs:group | xs:all | xs:choice | xs:sequence)?, ((xs:attribute | xs:attributeGroup)*, xs:anyAttribute?)))
       </xs:extension>

      -->
      <xs:extension xs:base="pc-Typ">
        <xs:sequence>
          <xs:element xs:name="ram" xs:type="xs:integer"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType xs:name="myPC-Typ2">
    <xs:complexContent>
      <xs:restriction xs:base="pc-Typ">
        <xs:sequence>
          <xs:element xs:name="name" xs:type="xs:string"/>
          <xs:element xs:name="hersteller" xs:type="xs:string"/>
          <xs:element xs:name="prozessor" xs:type="xs:string"/>
          <xs:element xs:name="mhz" xs:type="xs:integer" xs:minOccurs="0"/>
          <xs:element xs:name="kommentar" xs:type="xs:string" xs:minOccurs="0" xs:maxOccurs="1"/>
        </xs:sequence>
      </xs:restriction>
    </xs:complexContent>
  </xs:complexType>

  <!--
   Bei der Definition eines Typs ist es möglich festzulegen, ob und auf welche Art von diesem Typ weitere XML-Elementtypen abgeleitet werden dürfen.
   So kann man zum Beispiel festlegen, dass von einem Typ pc-Typ weitere Typen nur durch das Setzen weiterer Einschränkungen abgeleitet werden dürfen
   und nicht durch das Hinzufügen neuer Kindelemente.
  -->

  <!-- element definitions (with anonymous type declarations) -->

  <!--
   TODO:
   <xs:element
           abstract          = xs:boolean : "false", nur wenn globale definition
           block             = ( "#all" | list of ( "extension" | "restriction" | "substitution" ) )
           default           = xs:string
           final             = ( "#all" | list of ( "extension" | "restriction" ) ), nur wenn globale definition
           fixed             = xs:string
           form          = ( "qualified" | "unqualified" ), nicht wenn globale definition
           id                = xs:ID
           maxOccurs     = ( "0" | "1" ) : "1", nicht wenn globale definition
           minOccurs     = ( "0" | "1" ) : "1", nicht wenn globale definition
           name              = xs:NCName
           nillable          = xs:boolean : "false"
           ref           = xs:QName, nicht wenn globale definition
           substitutionGroup = xs:QName, nur wenn globale definition
           type              = xs:QName
           Content: (xs:annotation?, (xs:simpleType | xs:complexType)?, (xs:unique | xs:key | xs:keyref)*)
   </xs:element>
  -->

  <!-- type references -->

  <xs:element xs:name="head">
    <xs:complexType>
      <xs:sequence>
        <xs:element xs:name="title" xs:type="xs:string"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <!-- element references -->

  <xs:element xs:name="html">
    <xs:complexType>
      <xs:sequence>
        <xs:element xs:ref="head"/>
        <xs:element xs:name="body" xs:type="xs:string"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <!-- includes / imports / redefines -->

  <xs:include xs:schemaLocation="incl.xsd"/>
  <!--
   targetNamespace des harddisk.xsd muss mit dem des inkludierenden Schemas übereinstimmen.

   TODO:
   <xs:include
           id             = xs:ID
           schemaLocation = xs:anyURI
           Content: (xs:annotation?)
   </xs:include>

   xs:include performs a straight inclusion of a schema within another schema that describes the same target namespace.
   It is possible, though, to include a schema that doesn't specify a target namespace.
   The included schema will be treated as adopting the target namespace of its includer in a schema with a target namespace.

   The effect of a schema inclusion is a merge between the two schemas that are consolidated into a global schema. The schema that is included doesn't need to be a complete schema by itself. 

   It is not possible to use xs:include to include a schema describing another namespace. (xs:import should be used in this case.)
   It is not possible to change the definitions of the included schemas. (xs:redefine should be used in this case.) 

  -->

  <xs:import xs:namespace="http://dyomedea.com/ns/people" xs:schemaLocation="incl.xsd"/>
  <!-- xs:schemaLocation="simple-2-ns-ppl.xsd" -->
  <!--
   TODO:
   <xs:import
           id               = xs:ID
           namespace        = xs:anyURI
           schemaLocation   = xs:anyURI
           Content: (xs:annotation?)
   </xs:import>

   All the global definitions (elements, attributes, element and attribute groups, simple and complex types) and unique and key constraints
   of the imported schemas can be referenced using a namespace prefix defined for the corresponding namespace URI.

   <xs:schema targetNamespace="http://dyomedea.com/ns/library" xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:ppl="http://dyomedea.com/ns/people">
    <xs:import namespace="http://dyomedea.com/ns/people" schemaLocation="simple-2-ns-ppl.xsd"/>
                                 ...
            <xs:element ref="ppl:person" maxOccurs="unbounded"/>
                                 ...
   </xs:schema>

   xs:import must not be used to import component definitions from the target namespace (only xs:include / xs:redefine)

  -->

  <xs:redefine xs:schemaLocation="incl.xsd">
    <xs:complexType xs:name="Hersteller">
      <xs:complexContent>
        <xs:restriction xs:base="pcTeile:Hersteller">
          <xs:sequence>
            <xs:element xs:name="hersteller" xs:type="string" xs:minOccurs="10" xs:maxOccurs="10"/>
          </xs:sequence>
        </xs:restriction>
      </xs:complexContent>
    </xs:complexType>
  </xs:redefine>

  <!--
   TODO:
   <xs:redefine
           id             = xs:ID
           schemaLocation = xs:anyURI
           Content: (xs:annotation | (xs:simpleType | xs:complexType | xs:group | xs:attributeGroup))*
   </xs:redefine>

   xs:redefine is similar to xs:include with one exception: the definition of simple and complex types and attribute and element groups can be changed.
   Changes performed on these components must lead to     components that are valid restrictions or extensions of the original ones.
  -->

  <!-- MISSING ELEMENTS:

<xs:annotation
           id          = xs:ID
           Content: (xs:appinfo | xs:documentation)*
</xs:annotation>

<xs:appinfo
           source          = xs:anyURI
           Content: ({any})*
</xs:appinfo>

<xs:documentation
           source            = xs:anyURI
           xml:lang          = xml:lang
           Content: ({any})*
</xs:documentation>

globale definition (kann über ref-Attribut referenziert werden):
<xs:attribute
           default        = xs:string
           fixed          = xs:string
           id             = xs:ID
           name           = xs:NCName
           type           = xs:QName
           Content: (xs:annotation?, xs:simpleType?)
</xs:attribute>

lokale definition:
<xs:attribute
           default        = xs:string
           fixed          = xs:string
           form           = ( "qualified" | "unqualified" )
           id             = xs:ID
           name           = xs:NCName
           ref            = xs:QName
           type           = xs:QName
           use            = ( "prohibited" | "optional" | "required" ) : "optional"
           Content: ((xs:annotation?), (xs:simpleType?))
</xs:attribute>

globale definition:
<xs:attributeGroup
           id            = xs:ID
           name          = xs:NCName
           Content: (xs:annotation?, ((xs:attribute | xs:attributeGroup)*, xs:anyAttribute?))
</xs:attributeGroup>

lokale definition:
<xs:attributeGroup
           id           = xs:ID
           ref          = xs:QName
           Content: (xs:annotation?)
</xs:attributeGroup>

globale Definition:
<xs:group
           name               = xs:NCName
           Content: (xs:annotation?, (xs:all | xs:choice | xs:sequence))
</xs:group>

lokale Definition:
<xs:group
           id          = xs:ID
           maxOccurs   = ( xs:nonNegativeInteger | "unbounded" ) : "1"
           minOccurs   = xs:nonNegativeInteger : "1"
           ref         = xs:QName
           Content: (xs:annotation?)
</xs:group>

<xs:simpleContent
           id          = xs:ID
           Content: ((xs:annotation?), (xs:restriction | xs:extension))
</xs:simpleContent>

This element allows the definition of a simple content model by derivation of a simple type or of another simple content complex type.
It is not a component by itself (simple contents are not named) but rather declaration of the intention to define a simple content model by derivation. 

<xs:element name="title">
  <xs:complexType>
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute ref="lang"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>
</xs:element>

<xs:any
           id                 = xs:ID
           maxOccurs          = ( xs:nonNegativeInteger | "unbounded" ) : "1"
           minOccurs          = xs:nonNegativeInteger : "1"
           namespace          = ( ( "##any" | "##other" ) | list of ( xs:anyURI | ( "##targetNamespace" | "##local" ) ) ) : "##any"
           processContents    = ( "skip" | "lax" | "strict" ) : "strict"
           Content: (xs:annotation?)
</xs:any>

<xs:anyAttribute
           id                 = xs:ID
           namespace          = ( ( "##any" | "##other" ) | list of ( xs:anyURI | ( "##targetNamespace" | "##local" ) ) ) : "##any"
           processContents    = ( "skip" | "lax" | "strict" ) : "strict"
           Content: (xs:annotation?)
</xs:anyAttribute>

<xs:notation
           id            = xs:ID
           name          = xs:NCName
           public        = xs:token
           system        = xs:anyURI
           Content: (xs:annotation?)
</xs:notation>

<xs:notation name="pdf" public="application/pdf"
  system="file:///usr/bin/acroread"/>

<xs:simpleType name="graphicalFormat">
  <xs:restriction base="xs:NOTATION">
    <xs:enumeration value="jpeg"/>
    <xs:enumeration value="gif"/>
    <xs:enumeration value="png"/>
    <xs:enumeration value="svg"/>
    <xs:enumeration value="pdf"/>
  </xs:restriction>
</xs:simpleType>

  -->

  <!-- cabinet of curiosities -->

  <xs:element xs:name="kommentar" xs:type="xs:anyType"/>

  <xs:element xs:name="tagname">
    <xs:complexType xs:mixed="true">  <!-- text and tags can occur in mixed order -->
      <xs:sequence>
        <xs:element xs:name="child" xs:type="xs:integer" xs:minOccurs="0" xs:maxOccurs="unbounded"/>
        <!-- Weitere Elemente … -->
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <!--
   Von leeren XML-Elementen spricht man, wenn das jeweilige Element aus nur einem einzelnen XML-Tag besteht und keine weiteren XML-Elemente oder Text umschließt
   (z. B. der XHTML-Zeilenumbruch: <br />). XML Schema bedient sich an dieser   Stelle eines kleinen Tricks: Es wird mittels xs:complexType ein neuer Typ definiert,
   ohne ein Kindelement anzugeben. Da xs:complexType nach Vorgabe nur komplexe XML-Kindelemente als Inhalt zulässt, bleibt das jeweilige Element in diesem Fall leer.
  -->

  <!--
   Schlüssel: xs:key, xs:unique, xs:keyref ...

   <xs:unique
           id            = xs:ID
           name          = xs:NCName
           Content: ((xs:annotation?), (xs:selector, xs:field+))
   </xs:unique>

   <xs:field
           id             = xs:ID
           xpath          = xs:token
           Content: (xs:annotation?)
   </xs:field>

   <xs:key
           id            = xs:ID
           name          = xs:NCName
           Content: ((xs:annotation?), (xs:selector, xs:field+))
   </xs:key>

   <xs:keyref
           id            = xs:ID
           name          = xs:NCName
           refer         = xs:QName
           Content: ((xs:annotation?), (xs:selector, xs:field+))
   </xs:keyref>

   <xs:selector
           id             = xs:ID
           xpath          = xs:token
           Content: (xs:annotation?)
   </xs:selector>
  -->

</xs:schema>
